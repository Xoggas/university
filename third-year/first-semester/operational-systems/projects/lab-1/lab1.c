#include <stdio.h>    // Подключаем стандартную библиотеку для работы
// с функциями ввода и вывода (printf, scanf и т.д.)
#include <stdlib.h>   // Подключаем библиотеку для работы с различными 
// функциями стандартной библиотеки, например,
// для работы с памятью и функцией exit()
#include <unistd.h>   // Подключаем библиотеку для работы с системными 
// вызовами UNIX, такими как fork(), getpid(), sleep()
#include <time.h>     // Подключаем библиотеку для работы с временем, 
// используем для генерации случайных чисел и
// отображения системного времени
#include <sys/wait.h> // Подключаем библиотеку для работы с процессами, 
// в частности, для ожидания завершения порожденных
// процессов с помощью waitpid()
#include <signal.h>   // Подключаем библиотеку для работы с сигналами 
// в процессе (pause(), управление сигналами)

int main()
{

    // PID используется для идентификации процессов в операционной системе
    pid_t process_1_pid_global = -1, process_2_pid_global = -1,
            process_3_pid_global = -1, process_4_pid_global = -1;

    int status; // Используется в функциях waitpid() для отслеживания 
    // завершения процессов

    // Функция getpid() возвращает идентификатор текущего процесса
    process_1_pid_global = getpid();
    printf("Процесс 1 (PID: %d)\n", process_1_pid_global);

    // Порождаем новый процесс 2 с помощью системного вызова fork()
    // fork() создает копию текущего процесса (процесс 1), 
    // которая становится новым процессом (процессом 2)
    // Возвращаемое значение:
    // - В родительском процессе (процесс 1) fork() возвращает PID 
    // нового процесса (процесса 2)
    // - В процессе-потомке (процессе 2) fork() возвращает 0    

    process_2_pid_global = fork();

    // Проверяем, находимся ли мы в процессе-потомке (процессе 2)
    if (process_2_pid_global == 0)
    { // Это процесс 2

        // Функция getppid() возвращает PID родительского процесса 
        // (в данном сучае процесс 1)
        // Этот идентификатор используется для указания, какой 
        // процесс породил текущий процесс (процесс 2)
        // В контексте этого кода, getppid() вернет PID процесса 1 
        // для процесса 2

        printf("Процесс 2 (PID: %d) создан процессом 1 (PID: %d)\n",
               getpid(), getppid());

        // Порождаем процесс 3
        process_3_pid_global = fork();
        if (process_3_pid_global == 0)
        { // Это процесс 3
            printf("Процесс 3 (PID: %d) создан процессом 2 (PID: %d)\n",
                   getpid(), getppid());

            // Порождаем процесс 4
            process_4_pid_global = fork();
            if (process_4_pid_global == 0)
            { // Это процесс 4
                printf("Процесс 4 (PID: %d) создан процессом 3 (PID: %d). "
                       "Завершает свою работу.\n", getpid(), getppid());
                exit(0);
            }
            else
            {
                // Процесс 3 ожидает завершения процесса 4
                // Ожидаем завершения процесса 4 с помощью waitpid()
                // process_4_pid_global — это PID процесса 4
                // waitpid() приостанавливает выполнение текущего 
                // процесса (процесс 3), 
                // до тех пор, пока процесс 4 не завершится
                // Аргументы:
                // - process_4_pid_global: PID процесса
                // - &status: указатель на переменную, куда будет 
                // записан статус завершения процесса 4
                // - 0: процесс будет приостановлен до завершения 
                // дочернего процесса (ожидание завершения)
                waitpid(process_4_pid_global, &status, 0);
                srand(time(NULL) ^ (getpid() << 16));
                while (1)
                {
                    sleep(1); // Ждать 1 сек.
                    if (rand() % 3 == 0)
                    {
                        printf("Процесс 3 (PID: %d) завершает работу "
                               "(срабатывание 1/3)\n", getpid());
                        exit(0);
                        // Завершает процесс с кодом 0, 
                        // указывая на успешное завершение
                    }
                }
            }
        }
        else
        {
            while (1)
            {
                sleep(1);
                // Проверяем, завершился ли процесс 3 с помощью 
                // waitpid()
                // process_3_pid_global — это PID процесса 3
                // waitpid() не блокирует выполнение текущего 
                // процесса, так как используется флаг WNOHANG
                // Аргументы:
                // - process_3_pid_global: PID процесса
                // - &status: указатель на переменную для получения 
                // статуса завершения процесса
                // - WNOHANG: флаг, который указывает, что waitpid() 
                // не должен блокировать выполнение, 
                //   если процесс 3 ещё не завершился; функция 
                // вернет 0, если процесс всё ещё активен               

                pid_t result = waitpid(process_3_pid_global, &status, WNOHANG);
                if (result == 0)
                {
                    printf("Процесс 3 (PID: %d) еще работает... "
                           "Ну, погоди!\n", process_3_pid_global);
                }
                else if (result == process_3_pid_global)
                {
                    printf("Процесс 3 завершил свою работу.\n");
                    printf("Процесс 2 ждет 5 сек.\n");
                    sleep(5);
                    printf("Процесс 2 завершает свою работу.\n");
                    exit(0);
                }
            }
        }
    }
    else
    {
        // Процесс 1 (родительский процесс) ожидает завершения 
        // процесса 2
        waitpid(process_2_pid_global, &status, 0);
        // Проверяем, завершился ли процесс нормально с помощью 
        // макроса WIFEXITED
        // WIFEXITED(status) возвращает ненулевое значение (true), 
        // если процесс завершился 
        // нормально (через вызов exit())
        // Если процесс завершился с ошибкой или был прерван сигналом, 
        // WIFEXITED вернет 0 (false)
        if (WIFEXITED(status))
        {
            printf("Процесс 2 завершил свою работу.\n");
        }

        printf("Процесс 1 завершает свою работу и ждёт Ctrl+C\n");

        time_t current_time = time(NULL);
        printf("Текущее время: %s", ctime(&current_time));

        while (1)
        {
            pause();
            // pause() приостанавливает выполнение процесса до 
            // получения любого сигнала, который не игнорируется. 
            // Процесс возобновит свою работу, как только
            // будет получен сигнал. В данном случае это 
            // позволяет процессу 1 "ждать" завершения 
            // программы, пока его не прервут вручную (например, 
            // с помощью Ctrl+C).
        }

        printf("Процесс 1 завершил свою работу.\n");
    }

    return 0;
}
